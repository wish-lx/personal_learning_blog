(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{209:function(e,s,a){"use strict";a.r(s);var r=a(0),t=Object(r.a)({},function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"let-const-var"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-const-var","aria-hidden":"true"}},[e._v("#")]),e._v(" let const var")]),e._v(" "),a("ul",[a("li",[e._v("let const 针对块级作用域，没有变量提升（es6），声明之前使用会报错（TDZ）")]),e._v(" "),a("li",[e._v("var 针对函数作用域和全局作用域 ，存在变量提升（es5）,声明之前使用会赋值undefined")])]),e._v(" "),a("h2",{attrs:{id:"set和map区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set和map区别","aria-hidden":"true"}},[e._v("#")]),e._v(" set和map区别")]),e._v(" "),a("ul",[a("li",[e._v("Set 对象类似于数组，且成员的值都是唯一的。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 1];\nconst set = new Set();\narr.forEach(item => set.add(item));\nconsole.log(set);  // 1, 2, 3, 4, 5\n// 数组快速去重\nconsole.log([...new Set(arr)]);  //[1, 2, 3, 4, 5]\nset.add(5) // 添加\nset.has(5) // 是否存在5\nset.delete(5) // 删除5\nset.cleat()   // 清除集合中所有元素\nset.size  // 长度\n\n")])])]),a("ul",[a("li",[e._v("Map 对象是键值对集合，和 JSON 对象类似，但是 key 不仅可以是字符串还可以是对象")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var map = new Map();\nvar obj = { name: '小缘', age: 14 };\nmap.set(obj, '小缘喵');\nmap.get(obj); // 小缘喵\nmap.has(obj); // true\nmap.delete(obj) ;// true\nmap.has(obj); // false\nmap.clear(); // 移除集合中所有的键值对\nmap.size(); // 长度\nforEach\n")])])]),a("h1",{attrs:{id:"promise-all"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-all","aria-hidden":"true"}},[e._v("#")]),e._v(" promise.all")]),e._v(" "),a("ol",[a("li",[e._v("Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\n具体代码如下：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let p1 = new Promise((resolve, reject) => {\n resolve('成功了')\n})\n\nlet p2 = new Promise((resolve, reject) => {\n resolve('success')\n})\n\nlet p3 = Promse.reject('失败')\n\nPromise.all([p1, p2]).then((result) => {\n console.log(result)               //['成功了', 'success']\n}).catch((error) => {\n console.log(error)\n})\n\nPromise.all([p1,p3,p2]).then((result) => {\n console.log(result)\n}).catch((error) => {\n console.log(error)      // 失败了，打出 '失败'\n})\n")])])]),a("p",[a("strong",[e._v("需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的.\nPromse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。")])]),e._v(" "),a("h1",{attrs:{id:"promise-race"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise-race","aria-hidden":"true"}},[e._v("#")]),e._v(" promise.race")]),e._v(" "),a("ol",[a("li",[e._v("顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  },1000)\n})\n\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('failed')\n  }, 500)\n})\n\nPromise.race([p1, p2]).then((result) => {\n  console.log(result)\n}).catch((error) => {\n  console.log(error)  // 打开的是 'failed'\n})\n")])])]),a("p",[e._v("原理是挺简单的，但是在实际运用中还没有想到什么的使用场景会使用到。")])])},[],!1,null,null,null);s.default=t.exports}}]);