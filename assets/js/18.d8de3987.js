(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{202:function(t,e,s){"use strict";s.r(e);var i=s(0),n=Object(i.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"settimeout-经典面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-经典面试题","aria-hidden":"true"}},[t._v("#")]),t._v(" setTimeout 经典面试题")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//  请你预测一下代码会输出什么？\nfor(var i = 0; i <= 5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    },1000)\n}\n")])])]),s("ul",[s("li",[s("p",[t._v("如果你没有理解透js作用域和闭包的知识点的话，你可能会认为这道题的输出顺序是：\nfor循环，输出1，2，3，4，5.  或者循环输出1~5")])]),t._v(" "),s("li",[s("p",[t._v("但是实际的答案在log之后循环输出了五个数字6！！")])]),t._v(" "),s("li",[s("p",[t._v("接着可能面试官会让你改下代码，期望结果是每间隔一秒输出一个数字，即等待1秒  输出1，等待2秒 输出2，等到3秒 输出3....")])]),t._v(" "),s("li",[s("p",[t._v("回过来看看这段代码的执行顺序，首先for循环执行，在js引擎读到setTimeout时，因为setTimeout不是立即执行的，他们的回调会被push到宏任务队列中，再回头执行任务队列中的回调函数时，变量i早就变成了6。知道了原因，我们着手解决问题。这里我们需要给setTimeout创建一个闭包的环境，让它的回调函数顺利取到循环中的变量i就解决问题了。")])])]),t._v(" "),s("ol",[s("li",[t._v("使用IIFE（立即执行的匿名函数）")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//间隔1秒依次输出1，2，3，4, 5\nfor(var i = 1; i <= 5; i++) {\n    (function(i){\n        setTimeout(function() {\n            console.log(i);\n        }, i*1000)\n    })(i);\n}\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[t._v("使用ES6语法中的let来声明变量i\n==es6中的let声明的变量是具有块级作用域的，所以我们可以大胆的使用==")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("for(let i = 1;i <=5; i++) {\n    setTimeout(function() {\n        console.log(i);\n    },i*1000)\n}\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[t._v("使用bind方法")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("for(var i = 1; i <= 5; i++) {\n     setTimeout(function(i) {\n        console.log(i);\n    }.bind(null, i)，i*1000)\n}\n")])])]),s("ol",{attrs:{start:"4"}},[s("li",[t._v("利用setTimeout的第三个参数！！注意：setTineout的第三个参数及以后的参数都可以作为回调函数的参数哦")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("for(var i = 1; i<= 5;i++) {\n    setTimeout(function time(i) {\n        console.log(i);\n    },i*1000,i)\n }\n")])])]),s("ul",[s("li",[t._v("关于setTimeout的延时参数")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("setTimeout(function() {\n  console.log('代码执行了')；\n},3000)\n")])])]),s("ul",[s("li",[t._v("我们一般说代码在3秒之后执行，这样的说法是不严谨的。")]),t._v(" "),s("li",[t._v("准确的解释是：3秒后，setTimeout里的函数被推入event queue,而event queue里的任务，只有在主线程空闲下来之后才会去执行。\n如果主线程上有很多任务执行，超过3秒，比如执行了10秒，那么这个函数只能在10秒之后才能执行")]),t._v(" "),s("li",[t._v("另外：为了确保浏览器的执行一致，HTML5规范规定设置的最小延迟是4ms")])])])},[],!1,null,null,null);e.default=n.exports}}]);