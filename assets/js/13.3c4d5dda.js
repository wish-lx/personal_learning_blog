(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{215:function(e,n,t){"use strict";t.r(n);var s=t(0),i=Object(s.a)({},function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h2",{attrs:{id:"手写promise"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#手写promise","aria-hidden":"true"}},[this._v("#")]),this._v(" 手写promise")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Promise{\n    constructor(exector){\n        \x3c!-- 定义状态初始值 --\x3e\n        this state = 'pendding'\n        \x3c!-- 定义成功需要传递的值 --\x3e\n        this value = undefined\n        \x3c!-- 定义失败需要原因 --\x3e\n        this reason = undefined\n       let resolve = value => {\n           if(this.state === 'pending'){\n               this.state = 'fulfilled'\n               this.value = value\n           }\n       }\n       let reject = reason => {\n           if(this.state === 'pending'){\n               this.state = 'rejected'\n               this.reason = reason\n           }\n       }\n    }\n    try{\n      exector(resolve, reject)\n    }catch(err){\n      reject(err)\n    }\n    then(onResolved, onRejected){\n      if(this.state === 'fulfilled' ) {\n          onResolved(this.value)\n      } \n       if(this.state === 'rejected' ) {\n          onRejected(this.reason)\n      } \n    }\n}\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("class Promise{\n    constructor(fn){\n        \x3c!-- 初始化初始值为pendding --\x3e\n       this.state = 'pendding'\n       \x3c!-- 成功的值 --\x3e\n       this.value = undefined\n       \x3c!-- 失败的原因 --\x3e\n       this.reason = undefined\n       \x3c!-- 成功的回调 --\x3e\n       let resolve = value => {\n           if(this.state === 'pending'){\n               this.state = 'fulfilled'\n               this.value = value\n           }\n       }\n       \x3c!-- 失败的回调 --\x3e\n       let reject = reason => {\n           if(this.state === 'pending'){\n               this.state = 'rejected'\n               this.reason = reason\n           }\n       }\n    }\n    \x3c!-- 自执行   fn函数执行过程中如果报错，直接执行reject函数 --\x3e\n    try{\n      fn(resolve, reject)\n    }catch(err){\n      reject(err)\n    }\n    \x3c!-- then方法有两个参数，一举状态执行相应的回调 --\x3e\n    then(onFulfiled, onRejected){\n        if(this.state === 'fulfilled'){\n            onFulfiled(this.value)\n        }\n        if(this.state === 'rejected'){\n            onRejected(this.reason)\n        }\n    }\n}\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("手写promise\nclass Promise{\n    constructor(fn){\n       this.state = 'pending'\n       this.value = undefined\n       this.reason = undefined\n       let resolve = value => {\n           if(this.state === 'pending'){\n               this.state = 'fulfilled'\n               this.value = value\n           }\n       }\n       let reject = reason => {\n           if(this.state === 'pending'){\n               this.state = 'rejected'\n               this.reason = reason\n           }\n       }\n    }\n    try{\n        fn(resolve, reject)\n    }catch(err){\n        reject(err)\n    }\n    then(onFulfilled, onRejected){\n        if(this.state === 'Fulfilled'){\n            onFulfilled(this.value)\n        }\n        if(this.state === 'rejected'){\n            onFulfilled(this.reason)\n        }\n    }\n}\n")])])])])},[],!1,null,null,null);n.default=i.exports}}]);