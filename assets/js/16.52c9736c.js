(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{216:function(t,o,r){"use strict";r.r(o);var e=r(0),n=Object(e.a)({},function(){var t=this,o=t.$createElement,r=t._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"js的基本数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js的基本数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" js的基本数据类型")]),t._v(" "),r("ul",[r("li",[t._v("undefined null boolean number string Symbol（es6）\n"),r("ul",[r("li",[t._v("如果有一种机制，保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突。这也是ES6引入Symbol的原因。")]),t._v(" "),r("li",[t._v("在对象的内部使用Symbol值定义属性时，Symbol值必须放在方括号[ ] 中。")]),t._v(" "),r("li",[t._v("由于每一个Symbol的值都是不相等的，所以Symbol作为对象的属性名，可以保证属性不重名")])])])]),t._v(" "),r("h2",{attrs:{id:"判断数据类型方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断数据类型方法")]),t._v(" "),r("ol",[r("li",[t._v("typeof能够判断出除了null之外的普通数据类型（string、number、undefined、boolean），对象类型能够判断出function ，其他均为object。")]),t._v(" "),r("li",[t._v("instanceof 判断A是否的B的实例（判断的是原型），但是instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。")]),t._v(" "),r("li",[t._v("判断一个值是否为数组，使用Array.isArray()")]),t._v(" "),r("li",[t._v("最准确的判断数据类型的方法：Object.prototype.toString.call(obj)")])]),t._v(" "),r("h2",{attrs:{id:"普通函数与箭头函数区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#普通函数与箭头函数区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 普通函数与箭头函数区别")]),t._v(" "),r("ul",[r("li",[t._v("箭头函数的this已经指定，并且使用call  apply等方法无法进行更改")])]),t._v(" "),r("h2",{attrs:{id:"js为什么是单线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js为什么是单线程","aria-hidden":"true"}},[t._v("#")]),t._v(" js为什么是单线程")]),t._v(" "),r("ul",[r("li",[t._v("如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果")])]),t._v(" "),r("h2",{attrs:{id:"js原型链的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js原型链的理解","aria-hidden":"true"}},[t._v("#")]),t._v(" js原型链的理解")]),t._v(" "),r("h2",{attrs:{id:"js实现继承的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js实现继承的方式","aria-hidden":"true"}},[t._v("#")]),t._v(" js实现继承的方式")]),t._v(" "),r("h2",{attrs:{id:"原型链面试题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原型链面试题","aria-hidden":"true"}},[t._v("#")]),t._v(" 原型链面试题")]),t._v(" "),r("ul",[r("li",[t._v("每个对象都有__proto__，指向生成该对象的构造函数的原型。")]),t._v(" "),r("li",[t._v("函数的__proto__, 指向Function.prototype,")]),t._v(" "),r("li",[t._v("构造函数也是函数，构造函数的__proto__, 指向Function.prototype")]),t._v(" "),r("li",[t._v("Function.prototype属性是一个对象，而对象的__proto__，指向生成该对象的构造函数的原型，所以，Function.prototype."),r("strong",[t._v("proto")]),t._v("=== Object.prototype")])]),t._v(" "),r("hr"),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("var F = function () {}\nObject.prototype.a = function () {}\nFunction.prototype.b = function () {}\n\nvar f = new F()\n// 请问f有方法a  方法b吗\n")])])]),r("ol",[r("li",[r("p",[t._v("f的__proto__指向F.prototype，F.prototype.__proto__指向Object.prototype，所以f 可以取到a方法， 由于f的原型链上没经过Function.prototype，所以取不到b方法。")])]),t._v(" "),r("li",[r("p",[t._v("由于构造函数F是由Function new出来的，所以F.__proto__指向Function.prototype，所以F函数可以取到b方法。")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function Person(){}\n\nlet p1 = new Person()\nlet p2 = new Person()\nlet obj = {}\n// 写出 p1  p2  Person  Function   obj   Object等的原型链\n")])])]),r("ol",[r("li",[r("p",[t._v("p1:      "),r("strong",[t._v("proto")]),t._v(" :  Person.prototype")])]),t._v(" "),r("li",[r("p",[t._v("p2:      "),r("strong",[t._v("proto")]),t._v(" :  Person.prototype")])]),t._v(" "),r("li",[r("p",[t._v("Person  :         "),r("strong",[t._v("proto")]),t._v("： Function.prototype，    prototype： Person.prototype")])]),t._v(" "),r("li",[r("p",[t._v("Person.prototype ：         "),r("strong",[t._v("proto")]),t._v(" ： Object.prototype ，  constructor： Person")])]),t._v(" "),r("li",[r("p",[t._v("Function：       "),r("strong",[t._v("proto")]),t._v(" ： Function.prototype，   prototype： Function.prototype")])]),t._v(" "),r("li",[r("p",[t._v("Function.Prototype：     "),r("strong",[t._v("proto")]),t._v(" ：  Object.prototype ，   constructor：  Function")])]),t._v(" "),r("li",[r("p",[t._v("obj：    "),r("strong",[t._v("proto")]),t._v(" ： Object.prototype")])]),t._v(" "),r("li",[r("p",[t._v("Object：   "),r("strong",[t._v("proto")]),t._v(" ： Function.prototype  ，   prototype：  Object.prototype")])]),t._v(" "),r("li",[r("p",[t._v("Object.prototype：    "),r("strong",[t._v("proto")]),t._v(" ：  null  ，   constructor  ：  Object")])])])])},[],!1,null,null,null);o.default=n.exports}}]);