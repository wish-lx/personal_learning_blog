(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{206:function(t,e,a){"use strict";a.r(e);var r=a(0),s=Object(r.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react","aria-hidden":"true"}},[t._v("#")]),t._v(" react")]),t._v(" "),a("ol",[a("li",[t._v("声明式开发： 减少操作dom")]),t._v(" "),a("li",[t._v("可以与其他框架并存  jquery等")]),t._v(" "),a("li",[t._v("组件化")]),t._v(" "),a("li",[t._v("单向数据流")]),t._v(" "),a("li",[t._v("视图层框架")]),t._v(" "),a("li",[t._v("函数式编程")]),t._v(" "),a("li",[t._v("数据驱动")])]),t._v(" "),a("h2",{attrs:{id:"生态介绍："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生态介绍：","aria-hidden":"true"}},[t._v("#")]),t._v(" 生态介绍：")]),t._v(" "),a("ul",[a("li",[t._v("Vue：Vue + Vue-Router + Vuex + Axios + Babel + Webpack")]),t._v(" "),a("li",[t._v("React：React + React-Router+ Redux + Axios + Babel + Webpack")])]),t._v(" "),a("h2",{attrs:{id:"jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx","aria-hidden":"true"}},[t._v("#")]),t._v(" jsx")]),t._v(" "),a("ol",[a("li",[t._v("不需要包裹在单引号之内")]),t._v(" "),a("li",[t._v("可以使用自己创建的组件，但是组件名首字母要大写")]),t._v(" "),a("li",[t._v("jsx里面要使用js表达式要用{}包裹起来")]),t._v(" "),a("li",[t._v("修改数据要使用setState函数")])]),t._v(" "),a("h2",{attrs:{id:"propstypes-defaultprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#propstypes-defaultprops","aria-hidden":"true"}},[t._v("#")]),t._v(" propsTypes  defaultProps")]),t._v(" "),a("ol",[a("li",[t._v("propsTypes： 要求父组件在给子组件传值的时候，要求传值的类型是什么样子的")]),t._v(" "),a("li",[t._v("defaultProps：当父组件某个参数未传时，子组件自己设置默认值")])]),t._v(" "),a("h2",{attrs:{id:"props-state-render函数的关系（解释react数据驱动，数据变化，页面就跟着变化）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#props-state-render函数的关系（解释react数据驱动，数据变化，页面就跟着变化）","aria-hidden":"true"}},[t._v("#")]),t._v(" props state render函数的关系（解释react数据驱动，数据变化，页面就跟着变化）")]),t._v(" "),a("ol",[a("li",[t._v("当组件的state或者props发生改变的时候，render函数就会重新执行，页面就会重新渲染")]),t._v(" "),a("li",[t._v("当父组件的render函数被运行时，子组件的render函数也会被运行")])]),t._v(" "),a("h2",{attrs:{id:"react中的虚拟dom-jsx-reactelement-js对象-虚拟dom-真实dom-react-reactelement-div-id-abc-item"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中的虚拟dom-jsx-reactelement-js对象-虚拟dom-真实dom-react-reactelement-div-id-abc-item","aria-hidden":"true"}},[t._v("#")]),t._v(" react中的虚拟dom(jsx->reactElement->js对象(虚拟dom)-> 真实dom React.reactElement['div',{id:'abc'},item])")]),t._v(" "),a("ol",[a("li",[t._v("state数据")]),t._v(" "),a("li",[t._v("jsx模版")]),t._v(" "),a("li",[t._v("生成虚拟dom(虚拟dom就是一个js对象，用来描述真实的dom)---损耗性能")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("['div',{id:'abc'},['span',{},'hello']]\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[t._v("用虚拟dom结构生成真实的dom来显示")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  <div id="abc"><span>hello</span></div>\n')])])]),a("ol",{attrs:{start:"5"}},[a("li",[t._v("state数据发生变化")]),t._v(" "),a("li",[t._v("数据+ 模版 生成新的虚拟dom （极大的提升了性能）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("['div',{id:'abc'},['span',{},'aaa']]\n")])])]),a("ol",{attrs:{start:"7"}},[a("li",[t._v("比较原始虚拟dom和新的虚拟dom的区别，找到是span中的内容发生了改变（极大的提升了性能 ）--》 diff")]),t._v(" "),a("li",[t._v("直接操作dom，改变span中的内容")])]),t._v(" "),a("h2",{attrs:{id:"imutable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#imutable","aria-hidden":"true"}},[t._v("#")]),t._v(" imutable")]),t._v(" "),a("ol",[a("li",[t._v("不允许我们直接修改state的数据，如果想要修改可以复制一个副本")])]),t._v(" "),a("h2",{attrs:{id:"传参"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传参","aria-hidden":"true"}},[t._v("#")]),t._v(" 传参")]),t._v(" "),a("ol",[a("li",[t._v("父向子：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("父组件：  <TodoItem content = {item}></TodoItem>\n子组件：  <li>{this.props.content}</li>\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("子向父：")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("父组件： \n        <TodoItem content = {item} index={index}\n        delectItem = {this.delectItem}\n        ></TodoItem>\n子组件：\nrender(){\n        return(\n            <div onClick={this.delectItem}>\n                {this.props.content}\n            </div>\n        )\n    }\n    delectItem(){\n        this.props.delectItem(this.props.index)\n        // console.log(this.props.index)\n    }\n    父组件子组件相应的方法记得绑定相应的this实例\n")])])]),a("h2",{attrs:{id:"tips"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tips","aria-hidden":"true"}},[t._v("#")]),t._v(" tips")]),t._v(" "),a("ol",[a("li",[t._v("ui组件负责页面渲染  容器组件负责逻辑"),a("br"),t._v("\n//使用redux-thunk\n//    创建一个action\n//  const action = getInputChange(e.target.value)\n//    派发action\n// store.dispatch(action)")]),t._v(" "),a("li")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("dangerouslySetInnerHTML={{__html: item}} \n用来处理带标签的数据，但是容易导致XSS攻击\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("Immutable的set方法，会结合之前immutable的值和设置的值，返回一个全新的对象")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("case  actionType.INPUT_FOCUS:\n            //  Immutable的set方法，会结合之前immutable的值和设置的值，返回一个全新的对象\n           return state.set('foused', true)\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[a("p",[t._v("React-Redux: 是Redux的官方React绑定库。它能够使你的React组件从Redux store中读取数据，并且向store分发actions以更新数据,常用的有provider  connect\nreact-router-dom  link\n")])]),t._v(" "),a("li",[a("p",[t._v("immutable:")])])]),t._v(" "),a("ul",[a("li",[t._v("Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象")]),t._v(" "),a("li",[t._v("由于是不可变的，可以放心的对对象进行任意操作。在 React 开发中，频繁操作state对象或是 store ，配合 immutableJS 快、安全、方便")]),t._v(" "),a("li",[t._v("也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了Structural Sharing（结构共享）")]),t._v(" "),a("li",[t._v("常用API：\nfromJS()\n作用：将一个js数据转换为Immutable类型的数据\n用法：fromJS(value, converter)\n简介：value是要转变的数据，converter是要做的操作。第二个参数可不填，默认情况会将数组准换为List类型，将对象转换为Map类型，其余不做操作\ntoJS()\n作用：将一个Immutable数据转换为JS类型的数据\n用法：value.toJS()\nset()\n作用：设置第一层key、index的值\nmerge\n作用：浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，就数据中已存在的属性用新数据中的覆盖")])]),t._v(" "),a("h2",{attrs:{id:"diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法","aria-hidden":"true"}},[t._v("#")]),t._v(" diff算法")]),t._v(" "),a("ol",[a("li",[t._v("循环中引入key值是为了提高虚拟dom比对的性能，使用一个稳定的数值作为key值，不要使用index,index不稳定（为了使得旧的虚拟dom的值与新的虚拟dom的值保持一致）")]),t._v(" "),a("li",[t._v("setState是一个"),a("strong",[t._v("异步过程")]),t._v("，它可以把多次setState结合成一次setState,减少虚拟dom比对的次数，在比对的时候会有一个同层比较的概念，也就是diff算法在比较两个虚拟dom的时候，他会同层进行比较，如果一层不满足比对的要求，则不会再往下进行比对，直接就废弃掉，直接用新的替换掉，这样会大大的提升性能。")])]),t._v(" "),a("h2",{attrs:{id:"react的生命周期函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react的生命周期函数","aria-hidden":"true"}},[t._v("#")]),t._v(" react的生命周期函数")]),t._v(" "),a("ol",[a("li",[t._v("initialization（初始化): setup state and props")]),t._v(" "),a("li",[t._v("Mounting(挂载)：\n"),a("ul",[a("li",[t._v("componentWillMount：组件被挂载到页面之前，自动被执行（只在"),a("strong",[t._v("第一次挂载")]),t._v("时执行）")]),t._v(" "),a("li",[t._v("render： 挂载")]),t._v(" "),a("li",[t._v("componentDidMount: 组件被挂载到页面之后，自动被执行（只在"),a("strong",[t._v("第一次挂载")]),t._v("时执行）（"),a("strong",[t._v("在这里发送ajax请求")]),t._v("）")])])]),t._v(" "),a("li",[t._v("updating：\n"),a("ul",[a("li",[a("p",[t._v("prop：shouldComponentUpdate  true--》componentWillUpdate--》render--》componentDidUpdate")])]),t._v(" "),a("li",[a("p",[t._v("states： shouldComponentUpdate  true--》componentWillUpdate--》render--componentDidUpdate")])]),t._v(" "),a("li",[a("p",[t._v("componentWillReceiveProps--》 1.一个组件要从父组件接收参数 2.这个组件的render函数再次被渲染（不是首次）")])]),t._v(" "),a("li",[a("p",[t._v("shouldComponentUpdate--》组件在更新之前，自动会执行")])]),t._v(" "),a("li",[a("p",[t._v("componentWillUpdate--》组件被更新之前，自动会执行（在shouldComponentUpdate 执行，返回true 之后执行，返回false则不执行）")])]),t._v(" "),a("li",[a("p",[t._v("render--》")])]),t._v(" "),a("li",[a("p",[t._v("componentDidUpdate--》组件被更新之后，自动会执行")])])])]),t._v(" "),a("li",[t._v("UnMounting:\n"),a("ul",[a("li",[t._v("componentWillUnmounting: 当这个组件即将从页面中被剔除时，自动被执行")])])])]),t._v(" "),a("h2",{attrs:{id:"性能优化点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化点","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能优化点")]),t._v(" "),a("ol",[a("li",[t._v("shouldComponentUpdate： 可以避免无谓的render组件的运行")]),t._v(" "),a("li",[t._v("constructor中函数的作用域的绑定： 保证这个作用域的绑定只会执行一次，而且可以避免一些子组件无谓的渲染")]),t._v(" "),a("li",[t._v("setState是一个异步过程，可以把多次虚拟dom的比对结合成一次来做，降低虚拟dom比对的频率")]),t._v(" "),a("li",[t._v("虚拟dom  同层比对 key值")])])])},[],!1,null,null,null);e.default=s.exports}}]);