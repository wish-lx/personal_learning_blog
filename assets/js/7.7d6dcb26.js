(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{207:function(e,t,r){"use strict";r.r(t);var a=r(0),i=Object(a.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"js高级"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js高级","aria-hidden":"true"}},[e._v("#")]),e._v(" JS高级")]),e._v(" "),r("h1",{attrs:{id:"import与require区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#import与require区别","aria-hidden":"true"}},[e._v("#")]),e._v(" import与require区别")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("遵循规范\n– require 是 AMD规范引入方式\n– import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法")])]),e._v(" "),r("li",[r("p",[e._v("调用时间\n– require是运行时调用，所以require理论上可以运用在代码的任何地方\n– import是编译时调用，所以必须放在文件开头")])]),e._v(" "),r("li",[r("p",[e._v("require特点：")]),e._v(" "),r("ol",[r("li",[e._v("运行时加载")]),e._v(" "),r("li",[e._v("拷贝到本页面")]),e._v(" "),r("li",[e._v("全部引入")])])]),e._v(" "),r("li",[r("p",[e._v("import特点：")]),e._v(" "),r("ol",[r("li",[e._v("编译时加载")]),e._v(" "),r("li",[e._v("只引用定义")]),e._v(" "),r("li",[e._v("按需加载")])])])]),e._v(" "),r("h2",{attrs:{id:"事件轮询"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件轮询","aria-hidden":"true"}},[e._v("#")]),e._v(" 事件轮询")]),e._v(" "),r("h2",{attrs:{id:"宏任务微任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#宏任务微任务","aria-hidden":"true"}},[e._v("#")]),e._v(" 宏任务微任务")]),e._v(" "),r("ul",[r("li",[e._v("宏任务：包括整体代码script，setTimeout，setInterval。")]),e._v(" "),r("li",[e._v("微任务：Promise，process.nextTick。")])]),e._v(" "),r("h2",{attrs:{id:"深拷贝与浅拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝与浅拷贝","aria-hidden":"true"}},[e._v("#")]),e._v(" 深拷贝与浅拷贝")]),e._v(" "),r("h2",{attrs:{id:"object-create-底层实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-create-底层实现原理","aria-hidden":"true"}},[e._v("#")]),e._v(" Object.create()底层实现原理")]),e._v(" "),r("ul",[r("li",[e._v("通过Object.create()方法创建一个新对象，使新对象的__proto__原型指向通过create传入的对象")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("  let foo = {\n      age:10\n  };\n  let f = Object.create(foo);\n  console.log(f.age);//10\n\ncreate的内部原理:\n  Object.create => function(obj){\n      var f = function(){};\n      f.prototype = obj;\n      return new f();\n  }\n")])])]),r("ol",[r("li",[e._v("先在内部创建一个空构造函数")]),e._v(" "),r("li",[e._v("把构造函数的原型指向传进来的obj对象")]),e._v(" "),r("li",[e._v("通过new创建对象并返回")])]),e._v(" "),r("h2",{attrs:{id:"new操作符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new操作符","aria-hidden":"true"}},[e._v("#")]),e._v(" new操作符")]),e._v(" "),r("ol",[r("li",[e._v("当代码 new Foo(...) 执行时，会发生以下事情：")])]),e._v(" "),r("pre",[r("code",[e._v("- 一个继承自 Foo.prototype 的新对象被创建。\n- 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。\n- 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）")])])])},[],!1,null,null,null);t.default=i.exports}}]);