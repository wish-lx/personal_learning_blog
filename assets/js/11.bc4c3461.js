(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{211:function(n,a,s){"use strict";s.r(a);var t=s(0),e=Object(t.a)({},function(){var n=this,a=n.$createElement,s=n._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"async-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await","aria-hidden":"true"}},[n._v("#")]),n._v(" async await")]),n._v(" "),s("blockquote",[s("h3",{attrs:{id:"原文链接：https-www-jianshu-com-p-72e36168944f"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原文链接：https-www-jianshu-com-p-72e36168944f","aria-hidden":"true"}},[n._v("#")]),n._v(" 原文链接：https://www.jianshu.com/p/72e36168944f")])]),n._v(" "),s("ul",[s("li",[n._v("一、概念\n"),s("ul",[s("li",[n._v("1.明确概念\n"),s("ul",[s("li",[n._v("async函数就是generator函数的语法糖。async函数，就是将generator函数的*换成async，将yield替换成await。")]),n._v(" "),s("li",[n._v("【async函数对generator的改进】\n"),s("ul",[s("li",[n._v("(1)内置执行器，不需要使用next()手动执行。")]),n._v(" "),s("li",[n._v("(2)await命令后面可以是Promise对象或原始类型的值，yield命令后面只能是Thunk函数或Promise对象。")]),n._v(" "),s("li",[n._v("(3)返回值是Promise。返回非Promise时，async函数会把它包装成Promise返回。(Promise.resolve(value))")])])])])]),n._v(" "),s("li",[n._v("2.作用\n"),s("ul",[s("li",[n._v("异步编程的终极解决方案。")])])]),n._v(" "),s("li",[n._v("3.通俗理解（个人理解）\n"),s("ul",[s("li",[n._v("async/await，就是异步编程回调函数写法的替代方法。（使代码以同步方式的写法完成异步操作）")])])])])]),n._v(" "),s("li",[n._v("二、执行顺序\n"),s("ul",[s("li",[n._v("1.原理\n"),s("ul",[s("li",[n._v("函数执行时，一旦遇到await就会返回。等到触发的异步操作完成（并且调用栈清空），再接着执行函数体内后面的语句。")]),n._v(" "),s("li",[n._v("【个人理解】\n"),s("h4",{attrs:{id:"await语句后面的代码，相当于回调函数。（即：await的下一行开始，都视作回调函数的内容）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#await语句后面的代码，相当于回调函数。（即：await的下一行开始，都视作回调函数的内容）","aria-hidden":"true"}},[n._v("#")]),n._v(" await语句后面的代码，相当于回调函数。（即：await的下一行开始，都视作回调函数的内容）")]),n._v(" "),s("h4",{attrs:{id:"回调函数会被压入microtask队列，当主线程调用栈被清空时，去microtask队列里取出各个回调函数，逐个执行。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回调函数会被压入microtask队列，当主线程调用栈被清空时，去microtask队列里取出各个回调函数，逐个执行。","aria-hidden":"true"}},[n._v("#")]),n._v(" 回调函数会被压入microtask队列，当主线程调用栈被清空时，去microtask队列里取出各个回调函数，逐个执行。")]),n._v(" "),s("ul",[s("li",[n._v("await只是让当前async函数内部、后面的代码等待，并不是所有代码都卡在这里。遇到await就先返回，执行async函数之后的代码。")])])])])])])]),n._v(" "),s("li",[n._v("2.await执行细节\n"),s("ul",[s("li",[n._v("主线程执行过程中，遇到await后面的函数调用，会直接进入函数，并执行。")]),n._v(" "),s("li",[n._v("(1)当这个函数返回非promise：\n"),s("ul",[s("li",[n._v("await后面的代码被压入microtask队列。当主线程执行完毕，取出这个回调，执行。")])])]),n._v(" "),s("li",[n._v("(2)当这个函数返回promise：\n"),s("ul",[s("li",[n._v("await后面的代码被压入microtask队列。当主线程执行完毕，取出这个回调，发现await语句等待的函数返回了promise，把后续代码赋给这个promise对象的then，并把这个promise的回调再压入microtask队列，重新排队。当它前面的回调函数都被取出执行后，再取出它，执行。")])])])])])]),n._v(" "),s("h6",{attrs:{id:"栗子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栗子","aria-hidden":"true"}},[n._v("#")]),n._v(" 栗子:")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("【No1】await返回非promise\nasync function func1(){    \n    console.log('func1');\n    var a = await func2(); //当await返回非promise\n    console.log('func1 return');\n}\nfunction func2(){\n    console.log('func2');\n} //返回undefined\nfunc1();\nnew Promise(function(resolve){\n    console.log('promise1');\n    resolve('resolved');\n}).then(function(data){\n    console.log(data);\n});\n结果：\nfunc1\nfunc2\npromise1\nfunc1 return\nresolved\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("【No2】await返回promise\nasync function func1(){   \n    console.log('func1');   \n    var a = await func2(); //当await返回promise    \n    console.log('func1 return');\n}\nasync function func2(){    \n    console.log('func2');\n} //返回promise\nfunc1();\nnew Promise(function(resolve){   \nconsole.log('promise1');   \n resolve('resolved');\n}).then(function(data){   \n console.log(data);\n});\n结果：\nfunc1\nfunc2\npromise1\nresolved\nfunc1 return\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('【No3】await返回promise（来自头条笔试题）\n    async function async1() {     \n        console.log("async1 start");      \n        await  async2();     \n        console.log("async1 end");   \n     }  \n    async  function async2() {    \n        console.log( \'async2\');  \n    } \n     console.log("script start");  \n    setTimeout(function () {      \n        console.log("settimeout");  \n    },0);\n    async1();  \n    new Promise(function (resolve) {      \n        console.log("promise1");      \n        resolve();  \n    }).then(function () {      \n        console.log("promise2"); \n    }); \n    console.log(\'script end\');  \n    结果：\n    script start\n    async1 start\n    async2\n    promise1\n    script end\n    \n    promise2\n    async1 end\n    settimeout\n')])])])])},[],!1,null,null,null);a.default=e.exports}}]);